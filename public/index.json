[{"authors":["admin"],"categories":null,"content":"I am a Lecturer in the Department of Statistics, Faculty of Applied Sciences at the University of Sri Jayewardenepura. I received my PhD in Statistics from Monash University, Australia under the research title \u0026ldquo;Computationally efficient forecasting methods for large-scale real-time applications\u0026rdquo;. My thesis advisors were Professor Rob J Hyndman and Professor George Athanasopoulos.\nI enjoy solving general data science problems from three different angles: theoretical, computational, applied. In this website you will find some of my work and interests on statistics and data analysis. I am also interested in R programming language.\nPriyanga Dilini Talagala PhD in Statistics, Monash University, Australia is my sister.\n","date":1554595200,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a Lecturer in the Department of Statistics, Faculty of Applied Sciences at the University of Sri Jayewardenepura. I received my PhD in Statistics from Monash University, Australia under the research title \u0026ldquo;Computationally efficient forecasting methods for large-scale real-time applications\u0026rdquo;. My thesis advisors were Professor Rob J Hyndman and Professor George Athanasopoulos.\nI enjoy solving general data science problems from three different angles: theoretical, computational, applied. In this website you will find some of my work and interests on statistics and data analysis.","tags":null,"title":"Thiyanga S. Talagala","type":"authors"},{"authors":null,"categories":null,"content":"Abstract\nThis work presents two feature-based forecasting algorithms for large-scale time series forecasting. The algorithms involve computing a range of features of the time series which are then used to select the forecasting model. The forecasting model selection process is carried out using a pre-trained classifier. In our first algorithm we use a random forest algorithm to train the classifier. We call this framework FFORMS (Feature-based FORecast Model Selection). The second algorithm use efficient Bayesian multivariate surface regression approach to estimate forecast error for each method, and then using the minimum predicted error to select a forecasting model. Both algorithms have been evaluated using time series from the M4 competition, and is shown to yield accurate forecasts comparable to several benchmarks and other commonly used automated approaches in the time series forecasting literature. The methods are made available in the seer and fformpp packages in R.\nkeywords: Meta-learning, classification, surface regression\n","date":1562248800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562248800,"objectID":"af8c5c25ef74d00311b839d5dad2d118","permalink":"/talk/user19-talk/","publishdate":"2019-07-05T00:00:00+10:00","relpermalink":"/talk/user19-talk/","section":"talk","summary":"Abstract\nThis work presents two feature-based forecasting algorithms for large-scale time series forecasting. The algorithms involve computing a range of features of the time series which are then used to select the forecasting model. The forecasting model selection process is carried out using a pre-trained classifier. In our first algorithm we use a random forest algorithm to train the classifier. We call this framework FFORMS (Feature-based FORecast Model Selection). The second algorithm use efficient Bayesian multivariate surface regression approach to estimate forecast error for each method, and then using the minimum predicted error to select a forecasting model.","tags":null,"title":"Feature-based Time Series Forecasting","type":"talk"},{"authors":null,"categories":null,"content":" Abstract\nPeeking inside FFORMS: Feature-based FORecast Model Selection Thiyanga S. Talagala$^1$, Rob J. Hyndman$^1$, George Athanasopoulos$^1$\n$^1$Department of Econometrics and Business Statistics, Monash University, Australia\nFeatures of time series are useful in identifying suitable forecast models. Talagala, Hyndman \u0026amp; Athanasopoulos (2018) proposed a classification framework, called FFORMS (Feature-based FORecast Model Selection), which selects forecast models based on features calculated from the time series. The FFORMS framework builds a mapping that relates the features of a time series to the “best” forecast model using the random forest algorithm. In this paper we explore what is happening under the hood of the FFORMS framework and thereby gain an understanding of what features lead to the different choices of forecast models and how different features influence the predicted outcome. This is accomplished using model-agnostic machine learning interpretability approaches. Partial-dependency plots are used to visualize both main and interaction effects of features. The results of this study provide a valuable insight into how different features and their interactions affect the choice of forecast model selection. This gives a more refined picture of the relationship between features and the choice of forecast model which is particularly valuable for ongoing research in the field of feature-based time series analysis.\nKeywords: forecasting, time series, machine learning interpretability, black-box models, LIME\nReferences Talagala, TS, RJ Hyndman \u0026amp; G Athanasopoulos (2018). Meta-learning how to forecast time series. Working paper 6\u0026frasl;18. Monash University, Department of Econometrics and Business Statistics\n","date":1560175200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1560175200,"objectID":"71cd3124761c0328036aa141606bdbee","permalink":"/talk/isf19-talk/","publishdate":"2019-06-11T00:00:00+10:00","relpermalink":"/talk/isf19-talk/","section":"talk","summary":"Abstract\nPeeking inside FFORMS: Feature-based FORecast Model Selection Thiyanga S. Talagala$^1$, Rob J. Hyndman$^1$, George Athanasopoulos$^1$\n$^1$Department of Econometrics and Business Statistics, Monash University, Australia\nFeatures of time series are useful in identifying suitable forecast models. Talagala, Hyndman \u0026amp; Athanasopoulos (2018) proposed a classification framework, called FFORMS (Feature-based FORecast Model Selection), which selects forecast models based on features calculated from the time series. The FFORMS framework builds a mapping that relates the features of a time series to the “best” forecast model using the random forest algorithm.","tags":null,"title":"Peeking inside FFORMS: Feature-based FORecast Model Selection","type":"talk"},{"authors":null,"categories":["dplyr"],"content":" Packages\nlibrary(tidyverse) Load iris data set\ndata(\u0026quot;iris\u0026quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa summarise: to summarize only a single column iris %\u0026gt;% group_by(Species) %\u0026gt;% summarise(mean(Sepal.Length)) ## # A tibble: 3 x 2 ## Species `mean(Sepal.Length)` ## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; ## 1 setosa 5.01 ## 2 versicolor 5.94 ## 3 virginica 6.59  summarise_all: to summarize all columns iris %\u0026gt;% group_by(Species) %\u0026gt;% summarise_all(.funs = c(mean=\u0026quot;mean\u0026quot;)) ## # A tibble: 3 x 5 ## Species Sepal.Length_me… Sepal.Width_mean Petal.Length_me… ## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 setosa 5.01 3.43 1.46 ## 2 versic… 5.94 2.77 4.26 ## 3 virgin… 6.59 2.97 5.55 ## # … with 1 more variable: Petal.Width_mean \u0026lt;dbl\u0026gt;  summarise_at: to summarize only certain columns iris %\u0026gt;% group_by(Species) %\u0026gt;% summarise_at( .vars = vars(Sepal.Length, Sepal.Width), .funs = c(mean=\u0026quot;mean\u0026quot;)) ## # A tibble: 3 x 3 ## Species Sepal.Length_mean Sepal.Width_mean ## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 setosa 5.01 3.43 ## 2 versicolor 5.94 2.77 ## 3 virginica 6.59 2.97  summarise_if iris %\u0026gt;% group_by(Species) %\u0026gt;% summarise_if(.predicate = function(x) is.numeric(x), .funs = funs(mean=\u0026quot;mean\u0026quot;)) ## Warning: funs() is soft deprecated as of dplyr 0.8.0 ## Please use a list of either functions or lambdas: ## ## # Simple named list: ## list(mean = mean, median = median) ## ## # Auto named with `tibble::lst()`: ## tibble::lst(mean, median) ## ## # Using lambdas ## list(~ mean(., trim = .2), ~ median(., na.rm = TRUE)) ## This warning is displayed once per session. ## # A tibble: 3 x 5 ## Species Sepal.Length_me… Sepal.Width_mean Petal.Length_me… ## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 setosa 5.01 3.43 1.46 ## 2 versic… 5.94 2.77 4.26 ## 3 virgin… 6.59 2.97 5.55 ## # … with 1 more variable: Petal.Width_mean \u0026lt;dbl\u0026gt; pass multiple functions\niris %\u0026gt;% group_by(Species) %\u0026gt;% summarise_if(.predicate = function(x) is.numeric(x), .funs = funs(mean=\u0026quot;mean\u0026quot;, Sd=\u0026quot;sd\u0026quot;)) ## # A tibble: 3 x 9 ## Species Sepal.Length_me… Sepal.Width_mean Petal.Length_me… ## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; ## 1 setosa 5.01 3.43 1.46 ## 2 versic… 5.94 2.77 4.26 ## 3 virgin… 6.59 2.97 5.55 ## # … with 5 more variables: Petal.Width_mean \u0026lt;dbl\u0026gt;, Sepal.Length_Sd \u0026lt;dbl\u0026gt;, ## # Sepal.Width_Sd \u0026lt;dbl\u0026gt;, Petal.Length_Sd \u0026lt;dbl\u0026gt;, Petal.Width_Sd \u0026lt;dbl\u0026gt;  ","date":1558137600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1558137600,"objectID":"2184788d8c1b820cb4a3887072f53140","permalink":"/post/dplyr/","publishdate":"2019-05-18T00:00:00Z","relpermalink":"/post/dplyr/","section":"post","summary":"Summarizing variables with dplyr","tags":["R","dplyr"],"title":"Summarizing with dplyr","type":"post"},{"authors":["Thiyanga S. Talagala"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":null,"categories":["R","tidyverse","gganimate"],"content":" h2 { /* Header 2 */ font-size: 22px; color: DarkBlue; }  install packages To install multiple packages with a single call to install.packages, pass the names of the packages as a character vector to the install.packages() function.\ninstall.packages(c(\u0026quot;gganimate\u0026quot;, \u0026quot;tidyverse\u0026quot;, \u0026quot;gapminder\u0026quot;))  load packages Once you have the packages installed, you can make their contents available to use in your current R session by running,\nlapply(c(\u0026quot;gganimate\u0026quot;, \u0026quot;tidyverse\u0026quot;, \u0026quot;gapminder\u0026quot;), require, character.only = TRUE) ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] TRUE ## ## [[3]] ## [1] TRUE  check and install missing packages list.of.packages \u0026lt;- c(\u0026quot;gganimate\u0026quot;, \u0026quot;tidyverse\u0026quot;, \u0026quot;gapminder\u0026quot;) new.packages \u0026lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,\u0026quot;Package\u0026quot;])] if(length(new.packages)) install.packages(new.packages)  For other alternatives see littler  library(littler) install.r EIAdata gdata ggmap ggplot2  ipak  ipak \u0026lt;- function(pkg){ new.pkg \u0026lt;- pkg[!(pkg %in% installed.packages()[, \u0026quot;Package\u0026quot;])] if (length(new.pkg)) install.packages(new.pkg, dependencies = TRUE) sapply(pkg, require, character.only = TRUE) } # usage packages \u0026lt;- c(\u0026quot;gganimate\u0026quot;, \u0026quot;tidyverse\u0026quot;, \u0026quot;gapminder\u0026quot;) ipak(packages) ## gganimate tidyverse gapminder ## TRUE TRUE TRUE easypackages   ","date":1553212800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553212800,"objectID":"e9aed67f73f88a04797b48235d695908","permalink":"/post/multiplepkg/","publishdate":"2019-03-22T00:00:00Z","relpermalink":"/post/multiplepkg/","section":"post","summary":"Install multiple R packages at once/ check and install missing packages.","tags":["R","tidyverse","gganimate"],"title":"How to install and load multiple packages at once?","type":"post"},{"authors":null,"categories":null,"content":"Abstract\nThis work presents three feature-based algorithms for large-scale time series forecasting. The algorithms are developed based on meta-learning approach. In our first algorithm we use a random forest algorithm to identify the best forecasting model. We call this framework FFORMS (Feature-based FORecast Model Selection). In the second algorithm, FFORMA (Feature-based FORecast Model Averaging), we use gradient boosting to obtain the weights for forecast combinations. The third algorithm use efficient Bayesian multivariate surface regression approach to estimate forecast error for each method, and then using the minimum predicted error to select a forecasting model or to choose individual models for forecast combinations. The proposed algorithms perform well compared to several benchmarks and other commonly used approaches in large-scale forecasting.\n","date":1552395600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552395600,"objectID":"c68ed0dd55537c2b8012a18a3b0168f3","permalink":"/talk/beijingtalk19-talk/","publishdate":"2019-03-13T00:00:00+11:00","relpermalink":"/talk/beijingtalk19-talk/","section":"talk","summary":"Abstract\nThis work presents three feature-based algorithms for large-scale time series forecasting. The algorithms are developed based on meta-learning approach. In our first algorithm we use a random forest algorithm to identify the best forecasting model. We call this framework FFORMS (Feature-based FORecast Model Selection). In the second algorithm, FFORMA (Feature-based FORecast Model Averaging), we use gradient boosting to obtain the weights for forecast combinations. The third algorithm use efficient Bayesian multivariate surface regression approach to estimate forecast error for each method, and then using the minimum predicted error to select a forecasting model or to choose individual models for forecast combinations.","tags":null,"title":"Feature-based time series forecasting","type":"talk"},{"authors":[],"categories":[],"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":["R","Rmarkdown"],"content":"   alpha: beta: gamma delta   \\alpha : \\(\\alpha\\) \\beta: \\(\\beta\\) \\gamma: \\(\\gamma\\) \\delta: \\(\\delta\\)     \\Gamma: \\(\\Gamma\\) \\Delta: \\(\\Delta\\)   epsilon Zeta eta theta   \\epsilon: \\(\\epsilon\\) \\zeta: \\(\\zeta\\) \\eta: \\(\\eta\\) \\theta: \\(\\theta\\)   \\varepsilon: \\(\\varepsilon\\)   \\Theta: \\(\\Theta\\)   iota kappa lambda mu   \\iota: \\(\\iota\\) \\kappa: \\(\\kappa\\) \\lambda: \\(\\lambda\\) \\mu: \\(\\mu\\)   nu xi pi rho   \\nu: \\(\\nu\\) \\xi: \\(\\xi\\) \\pi: \\(\\pi\\) \\rho: \\(\\rho\\)    \\Xi: \\(\\Xi\\) \\Pi: \\(\\Pi\\)    sigma upsilon phi omicron   \\sigma: \\(\\sigma\\) \\upsilon: \\(\\upsilon\\) \\phi: \\(\\phi\\) \\omicron: \\(\\omicron\\)   \\Sigma: \\(\\Sigma\\)  \\Phi: \\(\\Phi\\)    tau chi psi Omega   \\tau: \\(\\tau\\) \\chi: \\(\\chi\\) \\psi: \\(\\psi\\) \\omega: \\(\\omega\\)     \\Psi: \\(\\Psi\\) \\Omega: \\(\\Omega\\)     ","date":1548720000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1548720000,"objectID":"366ba74a62a81c39577622b6c92c2105","permalink":"/post/greekletters/","publishdate":"2019-01-29T00:00:00Z","relpermalink":"/post/greekletters/","section":"post","summary":"Commands to type Greek letters on Rmarkdown or Latex","tags":["R","Rmarkdown"],"title":"Some useful Greek letters you might use on your reports","type":"post"},{"authors":null,"categories":["R","dplyr"],"content":" Sometimes we need to view all the functions that are built into an R package. This is done in the same way you would list variables in your workspace, using the ls function. Note that the package must be loaded before you run the ls command.\nUsage: Getting a list of functions inside the dplyr package\nlibrary(dplyr) ls(\u0026quot;package:dplyr\u0026quot;) ## [1] \u0026quot;%\u0026gt;%\u0026quot; \u0026quot;add_count\u0026quot; ## [3] \u0026quot;add_count_\u0026quot; \u0026quot;add_row\u0026quot; ## [5] \u0026quot;add_rownames\u0026quot; \u0026quot;add_tally\u0026quot; ## [7] \u0026quot;add_tally_\u0026quot; \u0026quot;all_equal\u0026quot; ## [9] \u0026quot;all_vars\u0026quot; \u0026quot;anti_join\u0026quot; ## [11] \u0026quot;any_vars\u0026quot; \u0026quot;arrange\u0026quot; ## [13] \u0026quot;arrange_\u0026quot; \u0026quot;arrange_all\u0026quot; ## [15] \u0026quot;arrange_at\u0026quot; \u0026quot;arrange_if\u0026quot; ## [17] \u0026quot;as_data_frame\u0026quot; \u0026quot;as_label\u0026quot; ## [19] \u0026quot;as_tibble\u0026quot; \u0026quot;as.tbl\u0026quot; ## [21] \u0026quot;as.tbl_cube\u0026quot; \u0026quot;auto_copy\u0026quot; ## [23] \u0026quot;band_instruments\u0026quot; \u0026quot;band_instruments2\u0026quot; ## [25] \u0026quot;band_members\u0026quot; \u0026quot;bench_tbls\u0026quot; ## [27] \u0026quot;between\u0026quot; \u0026quot;bind_cols\u0026quot; ## [29] \u0026quot;bind_rows\u0026quot; \u0026quot;case_when\u0026quot; ## [31] \u0026quot;changes\u0026quot; \u0026quot;check_dbplyr\u0026quot; ## [33] \u0026quot;coalesce\u0026quot; \u0026quot;collapse\u0026quot; ## [35] \u0026quot;collect\u0026quot; \u0026quot;combine\u0026quot; ## [37] \u0026quot;common_by\u0026quot; \u0026quot;compare_tbls\u0026quot; ## [39] \u0026quot;compare_tbls2\u0026quot; \u0026quot;compute\u0026quot; ## [41] \u0026quot;contains\u0026quot; \u0026quot;copy_to\u0026quot; ## [43] \u0026quot;count\u0026quot; \u0026quot;count_\u0026quot; ## [45] \u0026quot;cumall\u0026quot; \u0026quot;cumany\u0026quot; ## [47] \u0026quot;cume_dist\u0026quot; \u0026quot;cummean\u0026quot; ## [49] \u0026quot;current_vars\u0026quot; \u0026quot;data_frame\u0026quot; ## [51] \u0026quot;data_frame_\u0026quot; \u0026quot;db_analyze\u0026quot; ## [53] \u0026quot;db_begin\u0026quot; \u0026quot;db_commit\u0026quot; ## [55] \u0026quot;db_create_index\u0026quot; \u0026quot;db_create_indexes\u0026quot; ## [57] \u0026quot;db_create_table\u0026quot; \u0026quot;db_data_type\u0026quot; ## [59] \u0026quot;db_desc\u0026quot; \u0026quot;db_drop_table\u0026quot; ## [61] \u0026quot;db_explain\u0026quot; \u0026quot;db_has_table\u0026quot; ## [63] \u0026quot;db_insert_into\u0026quot; \u0026quot;db_list_tables\u0026quot; ## [65] \u0026quot;db_query_fields\u0026quot; \u0026quot;db_query_rows\u0026quot; ## [67] \u0026quot;db_rollback\u0026quot; \u0026quot;db_save_query\u0026quot; ## [69] \u0026quot;db_write_table\u0026quot; \u0026quot;dense_rank\u0026quot; ## [71] \u0026quot;desc\u0026quot; \u0026quot;dim_desc\u0026quot; ## [73] \u0026quot;distinct\u0026quot; \u0026quot;distinct_\u0026quot; ## [75] \u0026quot;distinct_all\u0026quot; \u0026quot;distinct_at\u0026quot; ## [77] \u0026quot;distinct_if\u0026quot; \u0026quot;distinct_prepare\u0026quot; ## [79] \u0026quot;do\u0026quot; \u0026quot;do_\u0026quot; ## [81] \u0026quot;dr_dplyr\u0026quot; \u0026quot;ends_with\u0026quot; ## [83] \u0026quot;enexpr\u0026quot; \u0026quot;enexprs\u0026quot; ## [85] \u0026quot;enquo\u0026quot; \u0026quot;enquos\u0026quot; ## [87] \u0026quot;ensym\u0026quot; \u0026quot;ensyms\u0026quot; ## [89] \u0026quot;eval_tbls\u0026quot; \u0026quot;eval_tbls2\u0026quot; ## [91] \u0026quot;everything\u0026quot; \u0026quot;explain\u0026quot; ## [93] \u0026quot;expr\u0026quot; \u0026quot;failwith\u0026quot; ## [95] \u0026quot;filter\u0026quot; \u0026quot;filter_\u0026quot; ## [97] \u0026quot;filter_all\u0026quot; \u0026quot;filter_at\u0026quot; ## [99] \u0026quot;filter_if\u0026quot; \u0026quot;first\u0026quot; ## [101] \u0026quot;frame_data\u0026quot; \u0026quot;full_join\u0026quot; ## [103] \u0026quot;funs\u0026quot; \u0026quot;funs_\u0026quot; ## [105] \u0026quot;glimpse\u0026quot; \u0026quot;group_by\u0026quot; ## [107] \u0026quot;group_by_\u0026quot; \u0026quot;group_by_all\u0026quot; ## [109] \u0026quot;group_by_at\u0026quot; \u0026quot;group_by_drop_default\u0026quot; ## [111] \u0026quot;group_by_if\u0026quot; \u0026quot;group_by_prepare\u0026quot; ## [113] \u0026quot;group_cols\u0026quot; \u0026quot;group_data\u0026quot; ## [115] \u0026quot;group_indices\u0026quot; \u0026quot;group_indices_\u0026quot; ## [117] \u0026quot;group_keys\u0026quot; \u0026quot;group_map\u0026quot; ## [119] \u0026quot;group_modify\u0026quot; \u0026quot;group_nest\u0026quot; ## [121] \u0026quot;group_rows\u0026quot; \u0026quot;group_size\u0026quot; ## [123] \u0026quot;group_split\u0026quot; \u0026quot;group_trim\u0026quot; ## [125] \u0026quot;group_vars\u0026quot; \u0026quot;group_walk\u0026quot; ## [127] \u0026quot;grouped_df\u0026quot; \u0026quot;groups\u0026quot; ## [129] \u0026quot;hybrid_call\u0026quot; \u0026quot;id\u0026quot; ## [131] \u0026quot;ident\u0026quot; \u0026quot;if_else\u0026quot; ## [133] \u0026quot;inner_join\u0026quot; \u0026quot;intersect\u0026quot; ## [135] \u0026quot;is_grouped_df\u0026quot; \u0026quot;is.grouped_df\u0026quot; ## [137] \u0026quot;is.src\u0026quot; \u0026quot;is.tbl\u0026quot; ## [139] \u0026quot;lag\u0026quot; \u0026quot;last\u0026quot; ## [141] \u0026quot;last_col\u0026quot; \u0026quot;lead\u0026quot; ## [143] \u0026quot;left_join\u0026quot; \u0026quot;location\u0026quot; ## [145] \u0026quot;lst\u0026quot; \u0026quot;lst_\u0026quot; ## [147] \u0026quot;make_tbl\u0026quot; \u0026quot;matches\u0026quot; ## [149] \u0026quot;min_rank\u0026quot; \u0026quot;mutate\u0026quot; ## [151] \u0026quot;mutate_\u0026quot; \u0026quot;mutate_all\u0026quot; ## [153] \u0026quot;mutate_at\u0026quot; \u0026quot;mutate_each\u0026quot; ## [155] \u0026quot;mutate_each_\u0026quot; \u0026quot;mutate_if\u0026quot; ## [157] \u0026quot;n\u0026quot; \u0026quot;n_distinct\u0026quot; ## [159] \u0026quot;n_groups\u0026quot; \u0026quot;na_if\u0026quot; ## [161] \u0026quot;nasa\u0026quot; \u0026quot;near\u0026quot; ## [163] \u0026quot;nest_join\u0026quot; \u0026quot;new_grouped_df\u0026quot; ## [165] \u0026quot;nth\u0026quot; \u0026quot;ntile\u0026quot; ## [167] \u0026quot;num_range\u0026quot; \u0026quot;one_of\u0026quot; ## [169] \u0026quot;order_by\u0026quot; \u0026quot;percent_rank\u0026quot; ## [171] \u0026quot;progress_estimated\u0026quot; \u0026quot;pull\u0026quot; ## [173] \u0026quot;quo\u0026quot; \u0026quot;quo_name\u0026quot; ## [175] \u0026quot;quos\u0026quot; \u0026quot;rbind_all\u0026quot; ## [177] \u0026quot;rbind_list\u0026quot; \u0026quot;recode\u0026quot; ## [179] \u0026quot;recode_factor\u0026quot; \u0026quot;rename\u0026quot; ## [181] \u0026quot;rename_\u0026quot; \u0026quot;rename_all\u0026quot; ## [183] \u0026quot;rename_at\u0026quot; \u0026quot;rename_if\u0026quot; ## [185] \u0026quot;rename_vars\u0026quot; \u0026quot;rename_vars_\u0026quot; ## [187] \u0026quot;right_join\u0026quot; \u0026quot;row_number\u0026quot; ## [189] \u0026quot;rowwise\u0026quot; \u0026quot;same_src\u0026quot; ## [191] \u0026quot;sample_frac\u0026quot; \u0026quot;sample_n\u0026quot; ## [193] \u0026quot;select\u0026quot; \u0026quot;select_\u0026quot; ## [195] \u0026quot;select_all\u0026quot; \u0026quot;select_at\u0026quot; ## [197] \u0026quot;select_if\u0026quot; \u0026quot;select_var\u0026quot; ## [199] \u0026quot;select_vars\u0026quot; \u0026quot;select_vars_\u0026quot; ## [201] \u0026quot;semi_join\u0026quot; \u0026quot;setdiff\u0026quot; ## [203] \u0026quot;setequal\u0026quot; \u0026quot;show_query\u0026quot; ## [205] \u0026quot;slice\u0026quot; \u0026quot;slice_\u0026quot; ## [207] \u0026quot;sql\u0026quot; \u0026quot;sql_escape_ident\u0026quot; ## [209] \u0026quot;sql_escape_string\u0026quot; \u0026quot;sql_join\u0026quot; ## [211] \u0026quot;sql_select\u0026quot; \u0026quot;sql_semi_join\u0026quot; ## [213] \u0026quot;sql_set_op\u0026quot; \u0026quot;sql_subquery\u0026quot; ## [215] \u0026quot;sql_translate_env\u0026quot; \u0026quot;src\u0026quot; ## [217] \u0026quot;src_df\u0026quot; \u0026quot;src_local\u0026quot; ## [219] \u0026quot;src_mysql\u0026quot; \u0026quot;src_postgres\u0026quot; ## [221] \u0026quot;src_sqlite\u0026quot; \u0026quot;src_tbls\u0026quot; ## [223] \u0026quot;starts_with\u0026quot; \u0026quot;starwars\u0026quot; ## [225] \u0026quot;storms\u0026quot; \u0026quot;summarise\u0026quot; ## [227] \u0026quot;summarise_\u0026quot; \u0026quot;summarise_all\u0026quot; ## [229] \u0026quot;summarise_at\u0026quot; \u0026quot;summarise_each\u0026quot; ## [231] \u0026quot;summarise_each_\u0026quot; \u0026quot;summarise_if\u0026quot; ## [233] \u0026quot;summarize\u0026quot; \u0026quot;summarize_\u0026quot; ## [235] \u0026quot;summarize_all\u0026quot; \u0026quot;summarize_at\u0026quot; ## [237] \u0026quot;summarize_each\u0026quot; \u0026quot;summarize_each_\u0026quot; ## [239] \u0026quot;summarize_if\u0026quot; \u0026quot;sym\u0026quot; ## [241] \u0026quot;syms\u0026quot; \u0026quot;tally\u0026quot; ## [243] \u0026quot;tally_\u0026quot; \u0026quot;tbl\u0026quot; ## [245] \u0026quot;tbl_cube\u0026quot; \u0026quot;tbl_df\u0026quot; ## [247] \u0026quot;tbl_nongroup_vars\u0026quot; \u0026quot;tbl_sum\u0026quot; ## [249] \u0026quot;tbl_vars\u0026quot; \u0026quot;tibble\u0026quot; ## [251] \u0026quot;top_frac\u0026quot; \u0026quot;top_n\u0026quot; ## [253] \u0026quot;transmute\u0026quot; \u0026quot;transmute_\u0026quot; ## [255] \u0026quot;transmute_all\u0026quot; \u0026quot;transmute_at\u0026quot; ## [257] \u0026quot;transmute_if\u0026quot; \u0026quot;tribble\u0026quot; ## [259] \u0026quot;trunc_mat\u0026quot; \u0026quot;type_sum\u0026quot; ## [261] \u0026quot;ungroup\u0026quot; \u0026quot;union\u0026quot; ## [263] \u0026quot;union_all\u0026quot; \u0026quot;validate_grouped_df\u0026quot; ## [265] \u0026quot;vars\u0026quot; \u0026quot;with_order\u0026quot; ## [267] \u0026quot;wrap_dbplyr_obj\u0026quot; ","date":1538697600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1538697600,"objectID":"bde5482c31ba3daddffaeeb0e02e40fb","permalink":"/post/packageinfo/","publishdate":"2018-10-05T00:00:00Z","relpermalink":"/post/packageinfo/","section":"post","summary":"Sometimes we need to view all the functions that are built into an R package.","tags":["R","dplyr"],"title":"What's in a package?","type":"post"},{"authors":null,"categories":["ggplot2"],"content":" Boxplot is probably one of the most common type of graphics. This will show how to customize boxplots.\nYou will learn,\n how to change the order of labels\n how to change the colours\n how to flip coordinates\n  Step 1: we create a simple data set.\nGender \u0026lt;- rep(c(\u0026quot;Male\u0026quot;, \u0026quot;Female\u0026quot;), times = 3, each = 4) Quality \u0026lt;- rep(c(\u0026quot;Taste\u0026quot;, \u0026quot;Color of package\u0026quot;, \u0026quot;Capacity\u0026quot;), times = 1, each = 8) Accepted \u0026lt;- seq(0, 100, by = 100/23) DF \u0026lt;- data.frame(Gender, Quality, Accepted) head(DF) ## Gender Quality Accepted ## 1 Male Taste 0.000000 ## 2 Male Taste 4.347826 ## 3 Male Taste 8.695652 ## 4 Male Taste 13.043478 ## 5 Female Taste 17.391304 ## 6 Female Taste 21.739130 Step 2: Generate a simple boxplot with ggplot\nlibrary(ggplot2) ggplot(DF, aes(x = Quality, y = Accepted, fill = Gender)) + geom_boxplot()  Step 3: Change the colours, legend position and x-axis order\nggplot(DF, aes(x = Quality, y = Accepted, fill = Gender)) + geom_boxplot() + scale_fill_manual(values = c(\u0026quot;green\u0026quot;, \u0026quot;orange\u0026quot;)) + xlab(\u0026quot;\u0026quot;) + theme(legend.position = \u0026quot;top\u0026quot;, legend.title = element_blank()) + scale_x_discrete(limits=c(\u0026quot;Taste\u0026quot;, \u0026quot;Color of package\u0026quot;, \u0026quot;Capacity\u0026quot;)) Step 4: Change the plotting order: first you have to include factor code to set the order of the levels.\nDF$Gender_factor \u0026lt;- factor(DF$Gender, levels=c(\u0026quot;Male\u0026quot;, \u0026quot;Female\u0026quot;)) ggplot(DF, aes(x = Quality, y = Accepted, fill = Gender_factor)) + geom_boxplot() + scale_fill_manual(values = c(\u0026quot;green\u0026quot;, \u0026quot;orange\u0026quot;)) + xlab(\u0026quot;\u0026quot;) + theme(legend.position = \u0026quot;top\u0026quot;, legend.title = element_blank()) + scale_x_discrete(limits=c(\u0026quot;Taste\u0026quot;, \u0026quot;Color of package\u0026quot;, \u0026quot;Capacity\u0026quot;)) Step 5: Horizontal bar chart: coord_flip()\nggplot(DF, aes(x = Quality, y = Accepted, fill = Gender)) + geom_boxplot() + scale_fill_manual(values = c(\u0026quot;green\u0026quot;, \u0026quot;orange\u0026quot;)) + xlab(\u0026quot;\u0026quot;) + theme(legend.position = \u0026quot;top\u0026quot;, legend.title = element_blank()) + coord_flip()+ scale_x_discrete(limits=c(\u0026quot;Taste\u0026quot;, \u0026quot;Color of package\u0026quot;, \u0026quot;Capacity\u0026quot;)) step 6: Change the legend order similar to plot order: under themes fill=guide_legend(reverse=FALSE)\nggplot(DF, aes(x = Quality, y = Accepted, fill = Gender)) + geom_boxplot() + scale_fill_manual(values = c(\u0026quot;green\u0026quot;, \u0026quot;orange\u0026quot;)) + xlab(\u0026quot;\u0026quot;) + theme(legend.position = \u0026quot;top\u0026quot;, legend.title = element_blank()) + guides(fill=guide_legend(reverse=TRUE)) + coord_flip()+ scale_x_discrete(limits=c(\u0026quot;Taste\u0026quot;, \u0026quot;Color of package\u0026quot;, \u0026quot;Capacity\u0026quot;)) ","date":1536105600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1536105600,"objectID":"448a002415287871d904008f85fcf5ae","permalink":"/post/blog/","publishdate":"2018-09-05T00:00:00Z","relpermalink":"/post/blog/","section":"post","summary":"Boxplot is probably one of the most common type of graphics. This will show how to customize boxplots.","tags":["R","ggplot2"],"title":"Customizing boxplots with ggplot2","type":"post"},{"authors":null,"categories":null,"content":"Working on this..\n","date":1533650400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1533650400,"objectID":"8c3f1d8fe352dc1260f12152b785396e","permalink":"/post/parallelcomputing/","publishdate":"2018-08-08T00:00:00+10:00","relpermalink":"/post/parallelcomputing/","section":"post","summary":"Working on this..","tags":[],"title":"Parallel computing with R","type":"post"},{"authors":null,"categories":null,"content":"coming up soon!\n","date":1533564000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1533564000,"objectID":"0544e9fe6dc4756a98072e0a4dca1b8e","permalink":"/post/datatypes/","publishdate":"2018-08-07T00:00:00+10:00","relpermalink":"/post/datatypes/","section":"post","summary":"coming up soon!","tags":[],"title":"Data Types in R","type":"post"},{"authors":null,"categories":null,"content":"Abstract\nMany applications require a large number of time series to be forecast. Providing better forecasts for these time series is important in decision and policy making. However, large scale time series data present numerous challenges in modelling and implementation due to the high dimensionality. It is unlikely that a single method will consistently provides better forecasts across all time series. On the other hand, selecting individual forecast models when the number of series is very large can be extremely challenging. In this paper we propose a classification framework which selects forecast models based on features calculated from the time series. A Random Forest approach is used to develop the classifier. The proposed framework is tested using the M3 data and is compared against several benchmarks and other commonly used approaches of forecasting.\n","date":1498399200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1498399200,"objectID":"e9693cefbfbe4b5fc9d03b6ee5b201ff","permalink":"/talk/isf17-talk/","publishdate":"2017-06-26T00:00:00+10:00","relpermalink":"/talk/isf17-talk/","section":"talk","summary":"Abstract\nMany applications require a large number of time series to be forecast. Providing better forecasts for these time series is important in decision and policy making. However, large scale time series data present numerous challenges in modelling and implementation due to the high dimensionality. It is unlikely that a single method will consistently provides better forecasts across all time series. On the other hand, selecting individual forecast models when the number of series is very large can be extremely challenging.","tags":null,"title":"Feature-based model selection for time series forecasting","type":"talk"},{"authors":null,"categories":null,"content":"The background pictures are of free copyright from https://pixabay.com/en/photos/presentation/.\nAssociated R package: seer\n","date":1483189200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483189200,"objectID":"e92016f7160966baa922bf6dcf76c69f","permalink":"/talk/jsm18-talk/","publishdate":"2017-01-01T00:00:00+11:00","relpermalink":"/talk/jsm18-talk/","section":"talk","summary":"https://ww2.amstat.org/meetings/jsm/2018/onlineprogram/AbstractDetails.cfm?abstractid=330245","tags":null,"title":"A classification framework for forecast-model selection","type":"talk"},{"authors":null,"categories":null,"content":"","date":1483189200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483189200,"objectID":"99fad8d2730a91524d4a348202ea3b47","permalink":"/talk/japan18-talk/","publishdate":"2017-01-01T00:00:00+11:00","relpermalink":"/talk/japan18-talk/","section":"talk","summary":"","tags":null,"title":"Analysing large collections of time series","type":"talk"},{"authors":null,"categories":null,"content":"","date":1483189200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483189200,"objectID":"c7ba5016f60dbd4bb60ee207effd5b93","permalink":"/talk/ssa17-talk/","publishdate":"2017-01-01T00:00:00+11:00","relpermalink":"/talk/ssa17-talk/","section":"talk","summary":"","tags":null,"title":"Feature-based model selection for time series forecasting","type":"talk"},{"authors":null,"categories":null,"content":"","date":1483189200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483189200,"objectID":"fcda67318c59693ce49660d71b6fdf6f","permalink":"/talk/ysc17-talk/","publishdate":"2017-01-01T00:00:00+11:00","relpermalink":"/talk/ysc17-talk/","section":"talk","summary":"","tags":null,"title":"Feature-based model selection for time series forecasting","type":"talk"},{"authors":null,"categories":null,"content":"Abstract\nA crucial task in time series forecasting is the identification of the most suitable forecasting method. We present a general framework for forecast model selection using meta-learning. A Random Forest is used to predict the best forecasting method using only time series features. The proposed framework has been evaluated using time series from the M1 and M3 competitions, and is shown to yield accurate forecasts comparable to several benchmarks and other commonly used automated approaches of time series forecasting. A key advantage of our algorithm is that the time-consuming part of building the random forest can be handled in advance of the forecasting task.\n","date":1483189200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483189200,"objectID":"299ac0d759174f6116404efa6267869a","permalink":"/talk/isf18-talk/","publishdate":"2017-01-01T00:00:00+11:00","relpermalink":"/talk/isf18-talk/","section":"talk","summary":"Abstract\nA crucial task in time series forecasting is the identification of the most suitable forecasting method. We present a general framework for forecast model selection using meta-learning. A Random Forest is used to predict the best forecasting method using only time series features. The proposed framework has been evaluated using time series from the M1 and M3 competitions, and is shown to yield accurate forecasts comparable to several benchmarks and other commonly used automated approaches of time series forecasting.","tags":null,"title":"Meta-learning how to forecast time series","type":"talk"},{"authors":null,"categories":null,"content":"Abstract\nThe seer package provides a novel framework for forecast model selection using time series features. We call this framework FFORMS (Feature-based FORecast Model Selection). The underlying approach involves computing a vector of features from the time series which are then used to select the forecasting model. The model selection process is carried out using a classification algorithm \u0026ndash; we use the time series features as inputs, and the best forecasting algorithm as the output. The classification algorithm can be built in advance of the forecasting exercise (so it is an “offline” procedure). Then, when we have a new time series to forecast, we can quickly compute its features, use the pre-trained classification algorithm to identify the best forecasting model, and produce the required forecasts. Thus, the “online” part of our algorithm requires only feature computation, and the application of a single forecasting model, with no need to estimate large numbers of models within a class, or to carry out a computationally-intensive cross-validation procedure. This framework is compared against several benchmarks and other commonly used forecasting methods.\nLink to git repository: seer\n","date":1483189200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483189200,"objectID":"55dccf4c5a29dd82879bd4f918a420a2","permalink":"/talk/user18-talk/","publishdate":"2017-01-01T00:00:00+11:00","relpermalink":"/talk/user18-talk/","section":"talk","summary":"Abstract\nThe seer package provides a novel framework for forecast model selection using time series features. We call this framework FFORMS (Feature-based FORecast Model Selection). The underlying approach involves computing a vector of features from the time series which are then used to select the forecasting model. The model selection process is carried out using a classification algorithm \u0026ndash; we use the time series features as inputs, and the best forecasting algorithm as the output.","tags":null,"title":"seer: R package for feature-based forecast model selection","type":"talk"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e6c4171b3bda35c314832458341d0a1a","permalink":"/project/timeseries/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/timeseries/","section":"project","summary":"","tags":["Demo"],"title":"Large-Scale Time Series Forecasting","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1e861e939c4099fff7d4ea706e24220","permalink":"/project/dengue/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/dengue/","section":"project","summary":"Potential impacts of climate change on dengue fever","tags":["Demo"],"title":"Small Bite Big threat","type":"project"},{"authors":["Thiyanga S. Talagala","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Thiyanga S. Talagala","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"}]